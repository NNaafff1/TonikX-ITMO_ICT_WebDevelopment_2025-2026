# Задание 2 - TCP Калькулятор

## Описание задания

Реализовать TCP сервер-калькулятор, который принимает от клиента три числа (a, b, h) и вычисляет результат по формуле: **(a + b) / h**. Сервер должен обрабатывать запросы клиентов и возвращать результат вычислений или сообщение об ошибке.

## Теоретические основы

**TCP (Transmission Control Protocol)** - это транспортный протокол, который:
- Требует установления соединения (three-way handshake)
- Гарантирует доставку пакетов
- Гарантирует порядок доставки
- Обеспечивает контроль ошибок
- Подходит для приложений, требующих надежности

### Отличия TCP от UDP

| Характеристика | TCP | UDP |
|----------------|-----|-----|
| Тип соединения | С установлением | Без установления |
| Надежность | Гарантированная | Не гарантированная |
| Порядок данных | Сохраняется | Не сохраняется |
| Скорость | Медленнее | Быстрее |
| Применение | HTTP, FTP, Email | Streaming, Gaming |

## Структура проекта

```
task2/
├── server.py        # TCP сервер-калькулятор
├── client.py        # Клиент для отправки запросов
└── mathematics.py   # Бизнес-логика вычислений
```

## Реализация

### Модуль mathematics.py

```python
from dataclasses import dataclass

@dataclass
class Math:
    a: int
    b: int
    h: int

    def do_math(self) -> float:
        return (self.a + self.b) / self.h

def parse_math(s: str) -> Math:
    parts = [p.strip() for p in s.split(",")]
    if len(parts) != 3:
        raise ValueError("expected three comma-separated numbers: a,b,h")
    return Math(int(parts[0]), int(parts[1]), int(parts[2]))
```

**Ключевые моменты:**

1. **Dataclass** - использование декоратора `@dataclass` для создания структуры данных
2. **Валидация** - проверка количества параметров
3. **Парсинг** - разбор строки с разделителями-запятыми
4. **Обработка ошибок** - выброс исключения при некорректном вводе

### Серверная часть (server.py)

```python
import socket
from mathematics import parse_math

HOST = "127.0.0.1"
PORT = 8082

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"TCP calculator server listening on {HOST}:{PORT}")
    while True:
        conn, addr = s.accept()
        with conn:
            print("Connected by", addr)
            data = conn.recv(4096)
            if not data:
                continue
            try:
                math = parse_math(data.decode())
                result = math.do_math()
                conn.sendall(str(result).encode())
            except Exception as e:
                conn.sendall(f"ERROR: {e}".encode())
```

**Основные компоненты:**

1. **Создание TCP сокета**
   - `SOCK_STREAM` - тип сокета для TCP
   
2. **Прослушивание соединений**
   - `listen(5)` - максимум 5 ожидающих подключений в очереди
   
3. **Принятие соединения**
   - `accept()` - блокируется до получения подключения
   - Возвращает новый сокет для общения с клиентом
   
4. **Обработка данных**
   - Получение данных через `recv()`
   - Парсинг и вычисление результата
   - Отправка ответа через `sendall()`
   
5. **Обработка ошибок**
   - Перехват исключений при парсинге
   - Отправка сообщения об ошибке клиенту

### Клиентская часть (client.py)

```python
import socket

HOST = "127.0.0.1"
PORT = 8082

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    while True:
        message = input("Enter three numbers a,b,h (or 'quit'): ")
        if message.lower() == 'quit':
            break
        s.sendall(message.encode())
        data = s.recv(4096)
        print(f"Result: {data.decode()}")
```

**Основные компоненты:**

1. **Установление соединения**
   - `connect((host, port))` - подключение к серверу
   
2. **Интерактивный ввод**
   - Цикл для множественных запросов
   - Возможность выхода через команду 'quit'
   
3. **Обмен данными**
   - Отправка данных через `sendall()`
   - Получение результата через `recv()`

## Запуск приложения

### Шаг 1: Запуск сервера

```bash
cd task2
python server.py
```

Ожидаемый вывод:
```
TCP calculator server listening on 127.0.0.1:8082
```

### Шаг 2: Запуск клиента (в новом терминале)

```bash
cd task2
python client.py
```

### Шаг 3: Примеры использования

**Пример 1: Корректный ввод**
```
Enter three numbers a,b,h (or 'quit'): 10,20,5
Result: 6.0
```

**Пример 2: Деление на ноль**
```
Enter three numbers a,b,h (or 'quit'): 10,20,0
Result: ERROR: division by zero
```

**Пример 3: Некорректный формат**
```
Enter three numbers a,b,h (or 'quit'): 10,20
Result: ERROR: expected three comma-separated numbers: a,b,h
```

**Пример 4: Нечисловые данные**
```
Enter three numbers a,b,h (or 'quit'): a,b,c
Result: ERROR: invalid literal for int() with base 10: 'a'
```

## Диаграмма взаимодействия

```
Клиент                          Сервер
  |                               |
  |-------- connect() ----------->|
  |                               |
  |<------- accept() -------------|
  |                               |
  |--- send("10,20,5") ---------->|
  |                          [parse_math]
  |                          [do_math: 6.0]
  |<------ send("6.0") -----------|
  |                               |
  |--- send("10,20,0") ---------->|
  |                          [parse_math]
  |                          [do_math: ERROR]
  |<---- send("ERROR...") --------|
  |                               |
  |-------- close() ------------->|
```

## Особенности реализации

!!! success "Обработка ошибок"
    Сервер корректно обрабатывает все типы ошибок и отправляет понятные сообщения клиенту

!!! info "Контекстный менеджер"
    Использование `with` гарантирует закрытие сокетов даже при возникновении исключений

!!! note "Однопоточность"
    Текущая реализация обрабатывает только одного клиента за раз

## Преимущества TCP для данной задачи

1. **Надежность** - гарантированная доставка результата вычислений
2. **Порядок** - сохранение порядка запрос-ответ
3. **Контроль ошибок** - автоматическая проверка целостности данных
4. **Удобство** - простота программирования для запрос-ответных сценариев

## Возможные улучшения

1. **Многопоточность** - обработка нескольких клиентов одновременно
2. **Расширенная математика** - поддержка других операций
3. **Логирование** - запись всех операций в файл
4. **Аутентификация** - проверка прав доступа клиентов
5. **Таймауты** - защита от зависших соединений
6. **Шифрование** - защита данных при передаче

## Выводы

В данном задании была реализована клиент-серверная архитектура на базе TCP протокола. Продемонстрированы:
- Основы работы с потоковыми сокетами
- Обработка пользовательского ввода
- Обработка исключений и ошибок
- Разделение бизнес-логики и сетевого кода
- Создание интерактивного клиентского приложения

TCP оказался подходящим выбором для калькулятора, так как требуется надежная доставка данных и сохранение порядка запросов.
